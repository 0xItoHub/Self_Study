Javaのラムダ式において「実質的な`final`」という概念は、ラムダ式や匿名クラスの内部で使用される外部変数（メソッド内のローカル変数など）に関連します。ラムダ式の中で使用する変数は、「実質的に`final`」である必要があります。

### 実質的な`final`とは？

実質的な`final`とは、`final`キーワードが付いていないけれども、実際には再代入されていない変数のことです。具体的には、以下の条件を満たす変数が実質的な`final`と見なされます。

- 変数が一度だけ初期化され、その後、再代入されていない。
- 変数が定義されたスコープ内で、初期化以外の代入操作が行われていない。

この「実質的に`final`」な性質を持つ変数は、`final`変数と同じようにラムダ式の中で安全に使用できるとコンパイラが判断します。

### 使用例

以下のコードは、ラムダ式内で「実質的に`final`」な変数を使用する例です。

```java
public class LambdaExample {
    public static void main(String[] args) {
        int number = 10; // 実質的にfinalな変数

        Runnable runnable = () -> {
            System.out.println("Number is: " + number);
        };

        runnable.run();
    }
}
```

この例では、`number`は一度だけ初期化され、その後再代入されていないため、「実質的に`final`」と見なされます。したがって、ラムダ式の中でこの変数を使用することができます。

### 実質的に`final`でない例

次のコードは、実質的に`final`ではない変数を使用しようとしてコンパイルエラーが発生する例です。

```java
public class LambdaExample {
    public static void main(String[] args) {
        int number = 10;

        number = 20; // 再代入されているため、実質的にfinalではない

        Runnable runnable = () -> {
            System.out.println("Number is: " + number); // コンパイルエラー
        };

        runnable.run();
    }
}
```

このコードでは、`number`が再代入されているため、「実質的に`final`」ではなくなり、ラムダ式内で使用しようとするとコンパイルエラーになります。

### なぜ実質的に`final`である必要があるのか？

ラムダ式や匿名クラスのインスタンスは、変数が最初に定義されたスコープよりも長く存在する可能性があります。そのため、ラムダ式内で使用される変数は、変更されないことが保証されていなければなりません。もし変数が再代入されると、ラムダ式がいつ実行されるかに応じて異なる値を参照することになり、予期しない動作を引き起こす可能性があります。

実質的に`final`であることを要求することで、Javaはこうした不安定な状況を防ぎ、ラムダ式の動作が確実に安定するようにしています。

### まとめ

- 実質的な`final`とは、`final`キーワードが付いていなくても、実際には再代入されない変数のことです。
- ラムダ式内で使用する変数は、「実質的に`final`」である必要があります。
- これは、ラムダ式が使用する変数が、予期しない変更を受けないようにするためです。

このルールを守ることで、ラムダ式は安定した動作を保証し、コードの予測可能性と安全性が高まります。
